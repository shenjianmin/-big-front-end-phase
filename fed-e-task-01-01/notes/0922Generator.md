2.5Generator
    ES2015提供的Generator生成器函数
    为什么要引入Generator：
        传统的JavaScript异步的实现是通过回调函数来实现的，但是这种方式有两个明显的缺陷：
            1.缺乏可信任性。例如我们发起ajax请求的时候是把回调函数交给第三方进行处理，期待它能执行我们的回调函数，实现正确的功能
            2.缺乏顺序性。众多回调函数嵌套使用，执行的顺序不符合我们大脑常规的思维逻辑，回调逻辑嵌套比较深的话调试代码时可能会难以定位。
        Promise恢复了异步回调的可信任性，而Generator正是以一种看似顺序、同步的方式实现了异步控制流程，增强了代码可读性。
    概念：
        Generator(生成器)是一类特殊的函数，跟普通函数声明时的区别是加了一个*号
            function *main() {
                // do something……
            }
        Iterator(迭代器)：当我们实例化一个生成器函数之后，这个实例就是一个迭代器。可以通过next()方法去启动生成器以及控制生成器的是否往下执行。
        yield/next：用来控制代码的执行顺序
        通过yield语句可以在生成器函数内部暂停代码的执行使其挂起，此时生成器函数仍然是运行并且是活跃的，其内部资源都会保留下来，只不过是处在暂停状态。
        在迭代器上调用next()方法可以使代码从暂停的位置开始继续往下执行。

2.6Async/Await语法糖
  相比于Generator最大的好处它不需要再配合一个类似co这样的执行器，因为他是语言层面的标准异步编程语法 其次 Async函数可以给我们返回一个Promise对象 这样更利于我们对整体代码进行控制 除此之外 还有一个点需要注意： async中使用的await关键词 只能出现在async函数内部 它不能直接在外部也就是最顶层作用于使用
